---
layout: Многопоточность, асинхронность и многопроцессорность в Python 
abstract: "В статье рассмотрены многопоточность, асинхронность и многопроцессорность в Python"
tags: 
  - асинхронность
  - многопроцессорность
  - многопоточность
image: threading_async_and_muliprocessing.png
---

# Многопоточность, асинхронность и многопроцессорность в Python

Питон – один из самых популярных языков программирования. 

С момента первого релиза он перетерпел немало корректировок. Питон имеет поддержку разного типа потоков, благодаря чему программы на `python` могут работать быстрее. Именно этому моменту будет посвящена статья.

## Основные определения

Вот несколько основных определений для процессов и потоков в `Python`:

**Процесс** - экземпляр программы, выполняющейся в операционной системе. Он имеет свой собственный адресное пространство, набор файловых дескрипторов, стек вызовов, регистры процессора и т.д.

**Поток** - часть процесса, которая может выполняться параллельно с другими частями процесса. Он имеет свой собственный стек вызовов, но использует общее адресное пространство с другими потоками в пределах процесса.

**GIL** (_Global Interpreter Lock_) - это механизм, используемый в интерпретаторе Python, который позволяет выполнять только один поток Python-кода в любой момент времени. **GIL** не позволяет Python-интерпретатору эффективно использовать несколько ядер процессора, что ограничивает его многопоточные возможности.

**Многопоточность** - это способность приложения работать с несколькими потоками выполнения. В Python, в силу GIL, многопоточность не всегда дает прирост производительности.

**Многопроцессность** - это способность приложения работать с несколькими процессами выполнения, каждый из которых имеет свой собственный адресное пространство и может выполняться параллельно с другими процессами. В Python многопроцессность может привести к улучшению производительности, но может также потреблять больше ресурсов, чем многопоточность.

**Асинхронность** в Python - это способ написания параллельного кода, который позволяет совершать несколько операций одновременно без использования **многопоточности** или **многопроцессорности**.

**CPU-bound** задачи являются теми, которые требуют много вычислительных ресурсов. Это могут быть задачи, связанные с математическими вычислениями, обработкой изображений, научными расчетами и т.д. В общем, CPU-bound задачи являются теми, которые требуют большого количества центрального процессорного времени (CPU time). Такие задачи могут быть довольно требовательными к ресурсам, и при их выполнении может возникнуть проблема с блокированием (blocking), когда вычисления занимают все доступные ресурсы и другие задачи не могут быть выполнены.

**I/O-bound**  задачи, напротив, связаны с операциями ввода-вывода (I/O), такими как чтение и запись файлов, сетевые запросы, базы данных и т.д. Эти задачи требуют меньше вычислительных ресурсов, но могут занимать значительное количество времени на ожидание результатов операций ввода-вывода. Это может приводить к тому, что процессор простаивает в ожидании завершения операций ввода-вывода, и другие задачи не могут быть выполнены.


## Модуль **Threading**

Модуль threading в Python предоставляет возможность создавать и управлять потоками выполнения внутри одного процесса. Он предоставляет высокоуровневый интерфейс для работы с потоками, что делает его более удобным и безопасным по сравнению с низкоуровневым модулем thread.

С помощью модуля _threading_ можно создавать потоки выполнения в `Python` и выполнять в них задачи параллельно с основным потоком. Каждый поток выполняется независимо и может иметь свои собственные переменные и выполнение кода.

Основные понятия, связанные с модулем threading:

- _Поток_ (Thread) - это легковесный процесс, который может быть запущен внутри другого процесса.
- _Lock_ - это объект, который может быть использован для синхронизации потоков выполнения. Он предоставляет механизмы для блокировки ресурсов, таких как переменные, и позволяет только одному потоку работать с ними в конкретный момент времени.
- _Event_ - это объект, который может использоваться для оповещения одного или нескольких потоков о наступлении определенного события.
- _Condition_ - это объект, который может использоваться для синхронизации потоков выполнения, основанных на условии. Он предоставляет механизмы для блокировки потоков до тех пор, пока определенное условие не будет выполнено.
- _Semaphore_ - это объект используемый для ограничения количества потоков, которые могут получить доступ к ресурсам одновременно.

Модуль **threading** также предоставляет механизмы для создания и управления потоками выполнения, такие как функции _Thread_, _Lock_, _Event_, _Condition_, _Semaphore_, которые могут быть использованы для создания многопоточных приложений.

Простой пример, который демонстрирует создание и запуск нескольких потоков в Python:

```python
import threading

def worker():
    """Функция, которую выполняет поток"""
    print(f"Starting thread {threading.current_thread().name}")
    # Некоторый полезный код
    print(f"Exiting thread {threading.current_thread().name}")

if __name__ == "__main__":
    # Создание потоков
    threads = []
    for i in range(5):
        t = threading.Thread(target=worker)
        threads.append(t)

    # Запуск потоков
    for t in threads:
        t.start()

    # Ожидание завершения всех потоков
    for t in threads:
        t.join()
```
Вывод программы:

```
Starting thread Thread-5 (worker)
Exiting thread Thread-5 (worker)
Starting thread Thread-6 (worker)
Exiting thread Thread-6 (worker)
Starting thread Thread-7 (worker)
Exiting thread Thread-7 (worker)
Starting thread Thread-8 (worker)
Exiting thread Thread-8 (worker)
Starting thread Thread-9 (worker)
Exiting thread Thread-9 (worker)
```
Как видно из примера, управление не будет передано другому потоку, пока текущий не будет закончен.

В этом примере мы создаем пять потоков и запускаем каждый из них. Каждый поток выполняет функцию _worker_, которая может содержать какой-то полезный код. После выполнения своей работы поток завершается. Запуская потоки в цикле, мы можем одновременно выполнять несколько задач. При необходимости мы можем дождаться завершения всех потоков с помощью метода _join_.

Модуль **threading** в `Python` используется для создания и управления потоками выполнения кода внутри одного процесса. Этот модуль удобен для выполнения задач, которые не блокируют поток выполнения, то есть не требуют ожидания завершения ввода-вывода _I/O_.

Однако, для выполнения _CPU-bound_ задач, таких как математические вычисления, использование _threading_ не будет эффективным, так как все потоки будут исполняться на одном физическом ядре, ввиду наличия в **GIL**.

Вместо этого для выполнения _CPU-bound_ задач рекомендуется использовать _multiprocessing_, которая позволяет распределять задачи на несколько физических ядер процессора.

## Модуль **multiprocessing**

**multiprocessing** - это модуль из стандартной библиотека `Python`, который предоставляет возможности для работы с процессами и выполнения параллельных задач на многоядерных системах. Он предоставляет множество классов и методов для создания и управления процессами, а также обмена данными между ними.

Основными концепциями, используемыми в модуле **multiprocessing**, являются _процессы_ и _очереди_.

_Процессы_ - это отдельные исполняемые единицы, каждый из которых имеет свою собственную область памяти и может выполняться независимо от других процессов. Каждый процесс создается с помощью класса _Process_ позволяющий передать функцию, которую нужно выполнить в новом процессе.

_Очереди_ - это механизм, позволяющий процессам обмениваться данными между собой. Для этого в модуле multiprocessing предоставляется класс Queue, который реализует простую очередь FIFO (First In, First Out).

Пример использования модуля multiprocessing:

```python
import multiprocessing
import time


def worker(name):
    print(f'Starting worker {name}')
    time.sleep(2)
    print(f'Finishing worker {name}')


if __name__ == '__main__':
    num_workers = 4
    pool = multiprocessing.Pool(num_workers)
    for i in range(num_workers):
        pool.apply_async(worker, args=(i,))
    pool.close()
    pool.join()
    print('All workers have finished')
```
Вывод прораммы:

```
Starting worker 0
Starting worker 1
Starting worker 2
Starting worker 3
Finishing worker 0
Finishing worker 1
Finishing worker 2
Finishing worker 3
All workers have finished
```

Из вывода, который предоставила программа, очевидно, что все процесссы работают паралельно.

## Модуль Asyncio

_Asyncio_ (сокращение от Asynchronous I/O) - это модуль в Python, который позволяет писать _асинхронный_ код для выполнения операций ввода-вывода (I/O) и других задач в параллельных потоках. Это позволяет использовать один поток для обработки нескольких задач, что может улучшить производительность и использование ресурсов.

Модуль **asyncio** стал стандартной частью языка Python начиная с версии **3.4**. Он предоставляет инфраструктуру для написания асинхронного кода в Python. До появления asyncio разработчики использовали различные сторонние библиотеки для написания асинхронного кода, такие как **Twisted** или **Tornado**. Однако asyncio стал более удобным и единообразным решением для асинхронного программирования в Python.

В **Asyncio** существует несколько основных понятий:

__Coroutines__ - это функции, которые используют ключевое слово _async_ вместо _def_, и вместо _return_ используют ключевое слово _await_, чтобы получить результат асинхронной операции.

__Event loop__ - это цикл, который запускает и управляет выполнением корутин. Он планирует выполнение задач и прерывает их выполнение, чтобы передать управление другим задачам. Это обеспечивает мультиплексирование ввода/вывода и позволяет выполнять асинхронный код без блокировки.

__Futures__ - это объекты, которые используются для передачи результатов от одной корутины к другой. Когда корутина ожидает результата асинхронной операции, она возвращает объект Future. Когда асинхронная операция завершается, результат записывается в этот объект.

__Task__ - это объект, который представляет конкретную корутину, запущенную в _event loop_. Он содержит состояние выполнения, результат выполнения и другую информацию, необходимую для управления выполнением корутины.

__Coroutine function__ - это функция, которая возвращает корутину, но не запускает ее. Она может быть запущена в event loop с помощью функции asyncio.run().

Асинхронные __итераторы__ и __генераторы__ - это итераторы и генераторы, которые используются в асинхронном коде. Они позволяют перебирать элементы асинхронно, без блокировки.

__Синхронный код__ - это код, который блокирует выполнение программы до завершения операции ввода/вывода. В **Asyncio** существуют средства для запуска синхронного кода в отдельном потоке или процессе, чтобы избежать блокировки __event loop__.

**Asyncio** предоставляет эффективный способ написания асинхронного кода в Python и позволяет эффективно использовать ресурсы компьютера для выполнения задач.

Модуль **asyncio** в `Python` предоставляет асинхронную поддержку ввода/вывода и работу с сетью в одном потоке. С версии `Python 3.8` в asyncio появились следующие новые возможности:

_asyncio.run()_: это новая функция, которая запускает событийный цикл **asyncio** и ожидает завершения корутины, переданной ей в качестве аргумента.

_asyncio.create_task()_: это новая функция, которая создает и запускает корутину в фоновом режиме внутри событийного цикла asyncio. Она заменяет устаревшую функцию _asyncio.ensure_future()_.

_asyncio.to_thread()_: это новая функция, которая запускает функцию в отдельном потоке и возвращает результат выполнения в корутине. Это полезно для выполнения блокирующих операций, которые могут заблокировать основной поток.

_asyncio.wait_for()_: это новая функция, которая используется для ожидания завершения корутины в течение определенного времени. Если корутина не завершается в течение указанного времени, возбуждается исключение **asyncio.TimeoutError**.

_asyncio.run_coroutine_threadsafe()_: это новая функция, которая позволяет запускать корутину в отдельном потоке и возвращать результат в основной поток.

_asyncio.current_task()_: это новая функция, которая возвращает текущую корутину, которая выполняется в событийном цикле asyncio.

_asyncio.all_tasks()_: это новая функция, которая возвращает список всех запущенных задач (корутин и Future) в событийном цикле asyncio.

_asyncio.get_running_loop()_: это новая функция, которая возвращает текущий событийный цикл asyncio, который выполняется в текущем потоке.

_asyncio.create_unix_connection()_ и _asyncio.create_unix_server()_: эти новые функции позволяют создавать соединения и сервера для работы с доменными сокетами UNIX.

_asyncio.start_tls()_: это новый метод для класса asyncio.StreamReaderProtocol, который позволяет установить защищенное SSL/TLS соединение.

Эти новые функции и методы позволяют более эффективно использовать **asyncio** для разработки асинхронных приложений в `Python`.

```python
import asyncio

async def say_hello():
    print("Hello")
    await asyncio.sleep(1)
    print("World")

async def main():
    tasks = []
    for _ in range(3):
        tasks.append(asyncio.create_task(say_hello()))
    await asyncio.gather(*tasks)

asyncio.run(main())
```

Вывод программы

```python
Hello
Hello
Hello
World
World
World
```
_async_ и _await_ - это ключевые слова в `Python`, которые используются для написания асинхронного кода с использованием asyncio библиотеки.

_async_ используется для определения функций, которые могут быть выполнены асинхронно, то есть без блокирования вызывающего потока, позволяя ему продолжать работу во время выполнения этой функции.

_await_ используется для ожидания выполнения асинхронной операции, которая может занять некоторое время. Оно блокирует выполнение текущей функции до тех пор, пока результат не будет готов, и позволяет другим операциям работать в это время.

Вместе они позволяют писать асинхронный код, который может быть выполнен более эффективно, чем традиционный синхронный код. Они могут быть использованы для написания быстрого, отзывчивого приложения, которое может обрабатывать множество запросов одновременно.

В этом примере мы создаем три корутины, каждая из которых печатает "Hello", ждет одну секунду и затем печатает "World". Затем мы создаем задачи для каждой корутины и запускаем их в цикле событий, используя функцию _asyncio.gather()_, которая ожидает завершения всех задач.

**Asyncio** позволяет эффективно использовать ресурсы компьютера для выполнения задач в параллельных потоках, особенно для операций ввода-вывода. Однако для **CPU**-bound задач, которые требуют большого количества вычислительных ресурсов, более эффективным может быть использование модуля _multiprocessing_.

## Заключение

В заключении можно сказать, что многопоточность, асинхронность и многопроцессорность являются важными инструментами для эффективной работы с вычислительными задачами в `Python`. Каждый из этих подходов имеет свои преимущества и недостатки, и выбор наиболее подходящего зависит от конкретной задачи.

Многопоточность позволяет ускорить выполнение **IO**-bound задач и использовать многопроцессорность, но сталкивается с ограничениями __GIL__, что может привести к снижению производительности в случае CPU-bound задач.

Многопроцессорность решает проблему __GIL__ и позволяет эффективно использовать все ядра процессора для _CPU-bound_ задач, но также имеет дополнительные накладные расходы на создание и управление процессами.

Асинхронность позволяет эффективно управлять __IO__-bound задачами, не блокируя основной поток выполнения, что повышает отзывчивость приложения, но может столкнуться с проблемой блокировок при работе с неблокирующими **IO**-операциями.

Таким образом, для достижения максимальной производительности и эффективности в `Python`, необходимо выбирать подход, который наилучшим образом соответствует требованиям конкретной задачи.
