---
layout: Объектно-ориентированное программирование в Python. Часть 2
abstract: "В статье рассмотрены возможности python в ООП"
tags:
  - oop
  - basic_python
  - basic_oop
image: oop.png
---

# Объектно-ориентированное программирование в Python. Часть 2

## Магические методы

Ранее в [статье]('https:rpopov94.github.io/articles/oop') были рассмотрены основные концепции ООП, также мы рассмотрели метод `__init__`, который является магическим методом, по сути является конструктором класса. 

Помимо обычных методов в классах, можно определять и магичесие методы.

Магические методы или _dunder_ - это методы, которые начинаются и заканчиваются двойными подчеркиваниями. Они используются для перегрузки операторов в Python и для реализации различных функций в классах. 

##### Зачем заключать их в двойные подчеркивания?

Смысл обертывания методов в двойное подчеркивание был в том, чтобы упростить синтаксис, т.к. создатели `python` старались не трогать стандартные методы, например, такие как `iter` или `call`, поэтому было решено обернуть такие методы в двойное подчеркивание. 

_dunder_ могут использоваться для эмуляции поведения встроенных типов по отношению к определяемым пользователем объектам. Рассмотрим следующий пример, в котором мы добавляем `len()` поддержку методов к нашему собственному объекту.


### Основные магические методы

Рассмотрим наиболее ипользуемые _dunders_ 

`__init__`: конструктор класса, который вызывается при создании нового экземпляра класса.

```python
class Person:
    def __init__(self, имя, возраст):
        self.name = name
        self.age = возраст
person = Person('Sarah', 25)
person
<__main__.Person at 0x157f83adc00>
```

`__str__` и `__repr__`: методы, которые возвращают строковое представление объекта, отличие `__repr` от `__str__`в том, что `__repr__` это метод, который возвращает строковое представление объекта, которое может быть использовано для создания нового экземпляра объекта.

```python
class Person:
    def __init__(self, age, name):
        self.name = name
        self.age = age
    def __str__(self):
        return "Person: {}, Age: {}".format(self.name , self.age)
>>> person = Person('Sarah', 25)
>>> print(person)
Person: Sarah, Age: 25
>>> person
<__main__.Person at 0x10d5807e8>
```

`__call__` может быть особенно полезен в классах с экземплярами, которым необходимо часто менять состояние. Вызов экземпляра может быть интуитивно понятным и элегантным способом изменения состояния объекта. Примером может быть класс, представляющий положение объекта на плоскости:

```python
class Point:
    '''Вызывается при обновлении позиции точки'''
    def __init__(self, size, x, y):
        self.x, self.y = x, y
        self.size = size

    def __call__(self, x, y):
        '''Изменение положения точки'''
        self.x, self.y = x, y

point = Point(10, 20)
print(point.x, point.y)  # 10 20
point(30, 40)
print (point.x, point.y) # 30 40
```

Реализация `__getitem__`, `__setitem__` в классе позволяет его экземплярам использовать оператор `[]`. Следовательно, методы `__getitem__` и `__setitem__` _dunder_ используются для индексации списков, поиска по словарю или доступа к диапазонам значений. Чтобы лучше понять концепцию, давайте рассмотрим пример, в котором мы создаем наш собственный пользовательский список.

```python
import random as ran
class CustomList:
    def __init__(self, num):
        self.my_list = [ran.randrange(1,101,1) for _ in range(num)]
obj = CustomList(5)
print(obj.my_list) # [16, 34, 67, 80, 39]
print(len(obj))    # TypeError: object of type 'CustomList' has no len()
for no in obj:
    print (no)     # TypeError: 'CustomList' object is not iterable
```

С приведенным выше определением класса мы не можем выполнять итерации по нашему объекту, поскольку приведенные выше инструкции вызывают `TypeError` . Давайте внедрим методы _dunder_ в наш класс, чтобы сделать его итеративным.

```python
import random as ran
class CustomList:
    def __init__(self, num):
        self.my_list = [ran.randrange(1,101,1) for _ in range(num)]
  
    def __str__(self):
        return str(self.my_list)
    def __setitem__(self, index, value):
        self.my_list[index] = value
    def __getitem__(self, index):
        return self.my_list[index]
    def __len__(self):
        return len(self.my_list)

obj = CustomList(5)
print(obj)    # [99, 45, 23, 23, 35]
len(obj)      # 5
print(obj[1]) # 45
```

## Заключение

Методы _dunder_ могут использоваться для эмуляции поведения встроенных типов для пользовательских объектов и являются основной функцией `Python`, которую следует использовать по мере необходимости.

Мы коснулись часто используемых методов _dunder_. Эти методы помогают в написании многофункциональных, элегантных и простых в использовании классов.В языке Python доступно множество методов _dunder_. Чтобы узнать о них больше, лучше всего ознакомиться со справочной документацией по Python.
