---
layout: Объектно-ориентированное программирование в Python
abstract: "В статье рассмотрены возможности python в ООП"
tags:
  - oop
  - basic_python
image: oop.png
---

# Объектно-ориентированное программирование в Python

Объектно-ориентированное программирование (ООП) - это парадигма программирования, которая позволяет описывать программные объекты и их взаимодействие друг с другом. Python - объектно-ориентированный язык программирования, что означает, что в нем есть множество инструментов для создания классов и объектов.

В этой статье мы рассмотрим основные принципы объектно-ориентированного программирования в Python.

В этой статье рассмотрим следующие аспекты:

a. Разница между объектно-ориентированным и процедурно-ориентированным программированием 

b. Классы и объекты

c. Методологии объектно-ориентированного программирования:
- Наследование
- Полиморфизм
- Инкапсуляцию
- Абстракцию

## Разница между объектно-ориентированным и процедурно-ориентированным программированием

И ООП и обычные функции могут сокращать количество написанного кода, какая есть разница между ООП и процедурном программировании?

ООП и процедурное программирование являются разными подходами к организации кода. ООП использует концепцию объектов, которые содержат данные и методы, связанные с этими данными, в то время как процедурное программирование стремится описать последовательность действий для выполнения задачи.

Основная разница между ООП и процедурным программированием заключается в том, как данные и функциональность обрабатываются и организовываются в коде.

В процедурном программировании функции являются основным строительным блоком кода, и они обрабатывают данные, передаваемые им в качестве параметров. В ООП, с другой стороны, данные и связанные с ними функции объединены в объекты, которые могут быть использованы для выполнения задач.

Использование ООП может существенно уменьшить количество кода, необходимого для написания программы, поскольку объекты можно повторно использовать в различных контекстах и сценариях. Кроме того, ООП способствует более четкому разделению задач и повышает переиспользуемость кода.

## Классы и объекты

В Python класс - это некий шаблон объекта, которое описывает атрибуты и методы. Всё то, что определено в классе может использоваться объектом этого класса. Классы в Python могут содержать переменные класса, переменные экземпляра и методы.

Для создания производного класса в `Python` используется ключевое слово _class_

Возьмём пример класса человек, каждому человеку присуще имя и возраст, напишем реализацию:

```python
class Human:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```
Cоздадим объект Vasya, и покажем что объекту Vasya доступны переменные name и age:

```python
vasya = Human(15, 'Вася')
print(vasya.age, vasya.name, 'лет') #Вася 15 лет
```
## Методологии объектно-ориентированного программирования

`Python` как и многие языки программирования поддерживает ООП, рассмотрим основные моменты:

### Наследование
В Python наследование - это механизм ООП, позволяющий создавать новый класс, который является производным от уже существующего класса (родительского класса), но при этом расширяет его функциональность.
Например, класс _Accountant_ может наследоваться от класса _Human_ следующим образом:

```python
class Accountant(Human):
    def __init__(self, name, age, company):
        super().__init__(name, age)
        self.company = company
     
```
В данном примере, класс Accountant наследует от класса Human, используя наследование "is-a" ("является"). Класс Accountant будет иметь доступ к атрибутам и методам класса Human, а также может добавлять свои собственные атрибуты и методы.

В конструкторе класса Accountant мы вызываем конструктор класса Human с помощью функции super(), чтобы инициализировать атрибуты имени и возраста. После этого мы инициализируем собственный атрибут company.
```python
human1 = Human("John", 30)
accountant1 = Accountant("Bob", 40, "ABC Company")

print(human1.name)          # John
print(accountant1.name)     # Bob
print(accountant1.age)      # 40
print(accountant1.company)  # ABC Company
```


### Полиморфизм

Полиморфизм в `Python` - это возможность объектов разных классов иметь одинаковое имя метода, но при этом выполнять разные действия. То есть один метод может работать по-разному в разных классах, но имя его остается одним и тем же.

Например, возьмем классы _Rectangle_ и _Circle_. У каждого класса есть метод _area()_, который вычисляет площадь фигуры. В классе Rectangle площадь вычисляется по формуле длины на ширину, а в классе _Circle_ - по формуле _pi*r^2_. Оба метода имеют одно и то же имя - _area()_, но выполняют разные действия.

```python
class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width

class Circle:
    def __init__(self, radius):
        self.radius = radius
        
    def area(self):
        return 3.14 * self.radius ** 2
```

Также в `Python` есть полиморфизм параметров. Это означает, что функция может принимать на вход объекты разных классов, но при этом работать с ними так, как будто они принадлежат одному классу. Например:

```python
class Dog:
    def __init__(self, name):
        self.name = name
    
    def sound(self):
        return "Woof!"

class Cat:
    def __init__(self, name):
        self.name = name
    
    def sound(self):
        return "Meow!"

def make_sound(animal):
    print(animal.sound())

dog = Dog("Buddy")
cat = Cat("Fluffy")

make_sound(dog)  # Вывод: Woof!
make_sound(cat)  # Вывод: Meow!
```

Здесь функция _make_sound()_ принимает на вход объекты классов Dog и Cat, которые имеют метод _sound()_. Но при этом, внутри функции мы можем обращаться к этому методу через одно и то же имя _sound()_, не зависимо от типа объекта, который передан на вход.

Таким образом, полиморфизм в `Python` позволяет сократить количество написанного кода и делает его более гибким и удобным в использовании.

### Инкапсуляция

_Инкапсуляция_ - это один из принципов объектно-ориентированного программирования, который позволяет скрыть реализацию деталей класса от внешнего мира и защитить данные класса от неправильного использования. В `Python` инкапсуляция может быть реализована с помощью модификаторов доступа, которые ограничивают доступ к атрибутам и методам класса.

Существует три модификатора доступа в `Python`:

- _public_ - атрибуты и методы, доступные для всех объектов, могут быть вызваны из любого места программы.

- _protected_ - атрибуты и методы, доступные только внутри класса и его подклассов, а также доступны из любого места программы, если к ним обращаются через имя класса.

- _private_ - атрибуты и методы, доступные только внутри класса, не могут быть вызваны извне.

Для создания _protected_ и _private_ атрибутов и методов в Python используется синтаксис двойного подчеркивания перед именем:

```python
class MyClass:
    def __init__(self):
        self.public_attr = 1
        self._protected_attr = 2
        self.__private_attr = 3

    def public_method(self):
        print("This is a public method")

    def _protected_method(self):
        print("This is a protected method")

    def __private_method(self):
        print("This is a private method")
```

В примере выше мы создали класс _MyClass_ со следующими атрибутами и методами:

1. public_attr - публичный атрибут.
2. _protected_attr - protected атрибут.
3. __private_attr - private атрибут. 
4. public_method() - публичный метод.
5. _protected_method() - protected метод.
6. __private_method() - private метод.

При обращении к _protected_ и _private_ атрибутам и методам извне класса можно использовать следующий синтаксис:

```python
obj = MyClass()
print(obj.public_attr) # 1
print(obj._protected_attr) # 2
print(obj._MyClass__private_attr) # 3
obj.public_method() # This is a public method
obj._protected_method() # This is a protected method
obj._MyClass__private_method() # This is a private method
```

В `Python` существует соглашение об именовании атрибутов и методов с различными уровнями доступа:

Атрибуты и методы, которые начинаются с двух подчеркиваний (__), считаются приватными и не могут быть вызваны или изменены извне класса. Например, метод ___foo()_ не может быть вызван из экземпляра класса или его наследника. Вместо этого можно вызвать метод с таким же именем, начинающийся с одного подчеркивания __foo_, который считается защищенным.
Атрибуты и методы, которые начинаются с одного подчеркивания (_), считаются защищенными и могут быть вызваны и изменены только из класса или его наследника.
При наследовании класс наследует все атрибуты и методы базового класса, в том числе и защищенные и приватные. Однако, при попытке вызова приватного метода базового класса из наследника может возникнуть ошибка.

Для вызова защищенного метода или изменения защищенного атрибута базового класса из наследника, необходимо использовать соответствующие имена, например, __foo()_ или __bar_.

```python
class Human:
    def __init__(self, name, age):
        self.name = name
        self._age = age
    
    def _show_age(self):
        print(f"My age is {self._age}")
    
    def __show_name(self):
        print(f"My name is {self.name}")
    
    def show_info(self):
        self.__show_name()
        self._show_age()
        

class Accountant(Human):
    def show_info(self):
        print("I'm an accountant!")
        super().show_info()
        

human = Human("John", 30)
accountant = Accountant("Anna", 25)

accountant._show_age() # My age is 25
accountant.__show_name() #AttributeError: 'Accountant' object has no attribute '__show_name'

human.show_info() # "My name is John" "My age is 30"
accountant.show_info() # "I'm an accountant!" "My name is Anna" "My age is 25"
```

Из кода видно, что из объекта возможно вызвать метод _show_age(), но при попытке вызова приватного метода ___show_name()_ получим ошибку аттрибута.

### Абстракция

Абстракция в `Python` - это процесс скрытия деталей реализации от пользователя и предоставление ему только интерфейса, необходимого для выполнения задачи. Она позволяет упрощать использование кода, сокращать время разработки и облегчать его сопровождение.

Один из способов создания абстракции в _Python_ - использование абстрактных классов и методов. Абстрактный класс - это класс, который не может быть создан напрямую, а может использоваться только для создания подклассов, реализующих его абстрактные методы. Абстрактный метод - это метод, который объявлен в абстрактном классе, но не имеет реализации. Он должен быть реализован в подклассах.

Для создания абстрактного класса в Python используется модуль `abc` _Abstract Base Classes_.

Пример создания абстрактного класса в Python:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass
```

Здесь класс Shape является абстрактным, так как он содержит абстрактные методы _area()_ и _perimeter()_. Эти методы не имеют реализации, они просто объявлены в абстрактном классе.

Пример создания подкласса, реализующего абстрактные методы:

```python
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
        
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
```

Здесь класс _Rectangle_ наследует абстрактный класс _Shape_ и реализует его абстрактные методы _area()_ и _perimeter()_.

Таким образом, абстракция позволяет использовать код более эффективно и удобно, а абстрактные классы и методы позволяют определять общие интерфейсы для классов и методов и повышать гибкость и переиспользуемость кода.

## Заключение

В заключение, _ООП_ в `Python` предоставляет возможность создавать более структурированный, модульный и легко управляемый код. Классы и объекты позволяют создавать объекты, которые могут содержать как данные, так и функциональность. Наследование позволяет создавать классы, которые наследуют функциональность от других классов, что позволяет избежать дублирования кода и облегчает его поддержку. Полиморфизм позволяет использовать объекты разных классов как если бы они были одного и того же класса, что делает код более универсальным и гибким. Инкапсуляция позволяет скрыть детали реализации от внешнего мира и предоставить только необходимый интерфейс.

Однако, не следует злоупотреблять _ООП_ и создавать слишком много классов или классов с избыточной функциональностью. Необходимо тщательно планировать и проектировать архитектуру приложения, чтобы избежать ошибок и сделать код более понятным и легко сопровождаемым. В целом, _ООП_ в `Python` - мощный инструмент, который позволяет создавать высокоуровневый, гибкий и модульный код.


