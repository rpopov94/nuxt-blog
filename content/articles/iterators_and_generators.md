---
layout: Итераторы vs генераторы
abstract: В статье рассмотрены что такое итераторы и генераторы в Python
tags:
  - iterators
  - generators
  - basic_python
image: iter_and_gens.png
---

# Итераторы vs генераторы

В Python итераторы и генераторы - это два мощных инструмента для работы с коллекциями данных. Они позволяют нам обрабатывать большие объемы данных эффективно и без загрузки всей коллекции в память.

**Итераторы**
Итератор - это объект, который содержит набор значений и предоставляет доступ к каждому из них по одному за раз. В Python большинство встроенных объектов, таких как списки, строки и словари, являются итерируемыми и могут быть использованы в качестве итераторов.

Чтобы создать итератор, необходимо определить два метода:

**__iter__()** - метод, который возвращает объект-итератор. Этот метод вызывается при инициализации итератора.
**__next__()** - метод, который возвращает следующий элемент коллекции при каждом вызове. Если элементов больше нет, вызывается исключение StopIteration.
Пример создания и использования итератора:

```python
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        value = self.data[self.index]
        self.index += 1
        return value

my_iterator = MyIterator([1, 2, 3])
for value in my_iterator:
    print(value)
```
Выводом будет `1, 2, 3 `

В данном примере мы создали класс MyIterator, который представляет итератор для списка данных. Метод **__next__()** возвращает каждый элемент списка по одному, пока не дойдет до конца списка, а затем вызывает исключение StopIteration. Метод **__iter__()** возвращает сам итератор.

Генераторы
Генератор - это функция, которая может выдавать значения по мере их генерации. В отличие от обычных функций, которые завершаются после того, как они возвращают значение, генератор может сохранять свое состояние между вызовами и продолжать работу там, где он остановился при следующем вызове.

Генераторы создаются с помощью ключевого слова **yield**, которое возвращает значение и приостанавливает выполнение функции до следующего вызова. Когда генератор вызывается снова, выполнение продолжается с того же места, где оно остановилось в предыдущий раз.

Пример создания и использования генератора:

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

```
В данном примере мы создали генератор _fibonacci_, который будет выдавать новое число Фибоначчи, после каждого вызова функции

Вызовем функцию:
```python
fib = fibonacci()
for i in range(10):
    print(next(fib))
```
Вывод
```python
0
1
1
2
3
5
8
13
21
34
```

В отличие от списков или кортежей, которые генерируются полностью и хранятся в памяти, итераторы и генераторы генерируют элементы последовательности по требованию. Таким образом, только один элемент хранится в памяти в любой момент времени, что позволяет экономить память и обеспечивать более эффективное использование ресурсов системы.

## Заключение

Итераторы и генераторы позволяют обрабатывать большие объемы данных эффективно и без загрузки всей коллекции в память. Они генерируют элементы последовательности по требованию, что позволяет экономить память и обеспечивать более эффективное использование ресурсов системы. Итераторы и генераторы могут быть использованы вместо списков, кортежей и других коллекций, чтобы уменьшить нагрузку на память и ускорить обработку данных.

Итераторы и генераторы имеют свои преимущества и недостатки. Итераторы могут быть более быстрыми и простыми в использовании для простых коллекций данных, таких как списки и словари. Генераторы могут быть более удобными и гибкими для более сложных операций, таких как обход дерева или поиска пути в графе.

Таким образом, выбор между использованием итераторов и генераторов зависит от конкретных требований и задач приложения. Однако в целом, использование итераторов и генераторов вместо списков и кортежей может повысить эффективность обработки данных и уменьшить нагрузку на память.
